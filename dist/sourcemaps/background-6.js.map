{"version":3,"sources":["app/scripts/background.js"],"names":["require","_events","_interopRequireDefault","_readableStream","_debounceStream","_loglevel","_webextensionPolyfill","_obsStore","_utils","_controllerUtils","_extensionPortStream","_ethRpcErrors","_snapsRpcMethods","_notificationServicesController","_app","_metametrics","_browserRuntime","_mv","_object","_keyringBridge","_selectors","_migrations","_migrator","_extension","_localStore","_networkStore","_sentryState","_createStreamSink","_notificationManager","_interopRequireWildcard","_metamaskController","_firstTimeState","_getFirstPreferredLangCode","_getObjStructure","_setup","_util","_offscreen","_marketingSiteWhitelist","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","prototype","hasOwnProperty","call","i","set","obj","BADGE_COLOR_APPROVAL","BADGE_COLOR_NOTIFICATION","BADGE_MAX_COUNT","inTest","localStore","global","stateHooks","getMostRecentPersistedState","mostRecentRetrievedState","sentry","firstTimeState","metamaskInternalProcessHash","ENVIRONMENT_TYPE_POPUP","ENVIRONMENT_TYPE_NOTIFICATION","ENVIRONMENT_TYPE_FULLSCREEN","metamaskBlockedPorts","setLevel","platform","notificationManager","openPopupCount","notificationIsOpen","uiIsTriggering","openMetamaskTabsIDs","requestAccountTabIds","controller","versionedData","tabOriginMapping","metamaskGetState","bind","phishingPageUrl","URL","phishingPageHref","toString","PHISHING_WARNING_PAGE_TIMEOUT","statePersistenceEvents","exports","promise","isInitialized","resolve","resolveInitialization","reject","rejectInitialization","deferredPromise","sendReadyMessageToTabs","async","tabs","query","url","windowType","then","result","checkForLastErrorAndLog","catch","tab","sendMessage","id","name","EXTENSION_MESSAGES","READY","connectRemote","connectExternalExtension","connectExternalCaip","saveTimestamp","timestamp","Date","toISOString","storage","session","initialize","offscreenPromise","isManifestV3","createOffscreen","initData","loadStateFromPersistence","initState","data","initLangCode","isFirstMetaMaskControllerSetup","_initState$Preference","PreferencesController","enableMV3TimestampSave","SAVE_TIMESTAMP_INTERVAL_MS","setInterval","sessionData","undefined","setupController","keyrings","trezorBridge","FakeTrezorBridge","ledgerBridge","FakeLedgerBridge","meta","theController","redirectTab","tabId","update","error","captureException","isManifestV2","webRequest","onBeforeRequest","addListener","details","TAB_ID_NONE","completedOnboarding","onboardingController","state","preferencesController","store","getState","usePhishDetect","initiator","host","hostname","href","searchParams","phishingController","maybeUpdateState","phishingTestResponse","test","blockedRequestResponse","isBlockedRequest","blockReason","type","metaMetricsController","trackEvent","event","MetaMetricsEventName","PhishingPageDisplayed","category","MetaMetricsEventCategory","Phishing","properties","reason","querystring","URLSearchParams","redirectUrl","hash","redirectHref","cancel","types","urls","maybeDetectPhishing","iframe","extensionStartupPhishingPageUrl","deferredResolve","deferredReject","window","document","createElement","setAttribute","loadComplete","Promise","addEventListener","body","appendChild","setTimeout","PhishingWarningPageTimeoutError","console","warn","remove","loadPhishingWarningPage","info","runtime","onConnect","args","onConnectExternal","_port$sender$tab","sender","Error","constructor","super","migrator","migrations","defaultVersion","on","generateInitialState","captureMessage","err","vaultStructure","extra","migrateData","isObject","version","setMetadata","emitDappViewedMetricEvent","origin","_permissions$eth_acco","metaMetricsId","shouldEmitDappViewedEvent","permissions","controllerMessenger","numberOfConnectedAccounts","eth_accounts","caveats","value","length","preferencesState","numberOfTotalAccounts","keys","identities","DappViewed","InpageProvider","referrer","is_first_visit","number_of_accounts","number_of_accounts_connected","trackDappView","remotePort","includes","isConnectedToDapp","isTabLoaded","title","overrides","stateMetadata","infuraProjectId","showUserConfirmation","triggerUi","browser","getRequestAccountTabIds","getOpenMetamaskTabsIds","currentMigrationVersion","featureFlags","getCurrentChainId","metamask","networkController","getIpfsGateway","getUseAddressBarEnsResolution","useAddressBarEnsResolution","provider","pipeline","storeAsStream","emit","getSentryAppState","backgroundState","memStore","maskObject","SENTRY_BACKGROUND_STATE","isClientOpenStatus","Boolean","onCloseEnvironmentInstances","isClientOpen","environmentType","onClientClosed","onEnvironmentTypeClosed","getBadgeLabel","count","maxCount","String","updateBadge","pendingApprovalCount","getPendingApprovalCount","unreadNotificationsCount","isNotificationServicesEnabled","isFeatureAnnouncementsEnabled","notificationServicesController","snapNotificationCount","values","notificationController","notifications","filter","notification","readDate","featureAnnouncementCount","metamaskNotificationsList","isRead","NotificationServicesController","Constants","TRIGGER_TYPES","FEATURES_ANNOUNCEMENT","walletNotificationCount","getUnreadNotificationsCount","label","badgeColor","badgeText","text","badgeBackgroundColor","color","action","setBadgeText","setBadgeBackgroundColor","browserAction","appStateController","waitingForUnlock","approvalController","getTotalApprovalCount","getUseRequestQueue","queuedRequestController","queuedRequestCount","_remotePort$sender","processName","isMetaMaskInternalProcess","sourcePlatform","getPlatform","senderUrl","PLATFORM_FIREFOX","_overrides$getPortStr","portStream","getPortStream","setupTrustedCommunication","finished","pathname","_overrides$getPortStr2","portStreamForPhishingPage","setupPhishingCommunication","connectionStream","onMessage","msg","method","MESSAGE_TYPE","ETH_REQUEST_ACCOUNTS","COOKIE_ID_MARKETING_WHITELIST_ORIGINS","some","_overrides$getPortStr3","portStreamForCookieHandlerPage","setUpCookieHandlerCommunication","_overrides$getPortStr4","setupUntrustedCommunicationEip1193","_overrides$getPortStr5","setupUntrustedCommunicationCaip","registerConnectListeners","decryptMessageController","hub","METAMASK_CONTROLLER_EVENTS","UPDATE_BADGE","encryptionPublicKeyController","signatureController","subscribe","APPROVAL_STATE_CHANGE","QUEUED_REQUEST_STATE_CHANGE","METAMASK_NOTIFICATIONS_LIST_UPDATED","METAMASK_NOTIFICATIONS_MARK_AS_READ","NOTIFICATIONS_STATE_CHANGE","NOTIFICATION_MANAGER_EVENTS","POPUP_CLOSED","automaticallyClosed","rejectUnapproved","REJECT_NOTIFICATION_CLOSE_SIG","REJECT_NOTIFICATION_CLOSE","pendingApprovals","forEach","ApprovalType","SnapDialogAlert","SnapDialogPrompt","DIALOG_APPROVAL_TYPES","accept","SnapDialogConfirmation","SNAP_MANAGE_ACCOUNTS_CONFIRMATION_TYPES","confirmAccountCreation","confirmAccountRemoval","showSnapAccountRedirect","ethErrors","userRejectedRequest","snapController","snaps","snap","preinstalled","updateBlockedSnaps","getActiveTabs","currentlyActiveMetamaskTab","find","isVivaldi","extData","indexOf","currentPopupId","getCurrentPopupId","showPopup","newPopupId","setCurrentPopupId","addAppInstalledEvent","updateTraits","MetaMetricsUserTrait","InstallDateExt","split","addEventBeforeMetricsOptIn","App","AppInstalled","onInstall","openExtensionInBrowser","onActivated","onActivatedTab","currentOrigin","permissionController","subjects","cleanUpMostRecentRetrievedState","initBackground"],"mappings":"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","file":"../metamask/background-6.js","sourcesContent":["/**\n * @file The entry point for the web extension singleton process.\n */\n\n// Disabled to allow setting up initial state hooks first\n\n// This import sets up global functions required for Sentry to function.\n// It must be run first in case an error is thrown later during initialization.\nimport './lib/setup-initial-state-hooks';\n\nimport EventEmitter from 'events';\nimport { finished, pipeline } from 'readable-stream';\nimport debounce from 'debounce-stream';\nimport log from 'loglevel';\nimport browser from 'webextension-polyfill';\nimport { storeAsStream } from '@metamask/obs-store';\nimport { isObject } from '@metamask/utils';\nimport { ApprovalType } from '@metamask/controller-utils';\nimport PortStream from 'extension-port-stream';\n\nimport { ethErrors } from 'eth-rpc-errors';\nimport { DIALOG_APPROVAL_TYPES } from '@metamask/snaps-rpc-methods';\nimport { NotificationServicesController } from '@metamask/notification-services-controller';\n\nimport {\n  ENVIRONMENT_TYPE_POPUP,\n  ENVIRONMENT_TYPE_NOTIFICATION,\n  ENVIRONMENT_TYPE_FULLSCREEN,\n  EXTENSION_MESSAGES,\n  PLATFORM_FIREFOX,\n  MESSAGE_TYPE,\n  ///: BEGIN:ONLY_INCLUDE_IF(keyring-snaps)\n  SNAP_MANAGE_ACCOUNTS_CONFIRMATION_TYPES,\n  ///: END:ONLY_INCLUDE_IF\n} from '../../shared/constants/app';\nimport {\n  REJECT_NOTIFICATION_CLOSE,\n  REJECT_NOTIFICATION_CLOSE_SIG,\n  MetaMetricsEventCategory,\n  MetaMetricsEventName,\n  MetaMetricsUserTrait,\n} from '../../shared/constants/metametrics';\nimport { checkForLastErrorAndLog } from '../../shared/modules/browser-runtime.utils';\nimport { isManifestV3 } from '../../shared/modules/mv3.utils';\nimport { maskObject } from '../../shared/modules/object.utils';\nimport { FIXTURE_STATE_METADATA_VERSION } from '../../test/e2e/default-fixture';\nimport { getSocketBackgroundToMocha } from '../../test/e2e/background-socket/socket-background-to-mocha';\nimport {\n  OffscreenCommunicationTarget,\n  OffscreenCommunicationEvents,\n} from '../../shared/constants/offscreen-communication';\nimport {\n  FakeLedgerBridge,\n  FakeTrezorBridge,\n} from '../../test/stub/keyring-bridge';\nimport { getCurrentChainId } from '../../ui/selectors';\nimport migrations from './migrations';\nimport Migrator from './lib/migrator';\nimport ExtensionPlatform from './platforms/extension';\nimport LocalStore from './lib/local-store';\nimport ReadOnlyNetworkStore from './lib/network-store';\nimport { SENTRY_BACKGROUND_STATE } from './constants/sentry-state';\n\nimport createStreamSink from './lib/createStreamSink';\nimport NotificationManager, {\n  NOTIFICATION_MANAGER_EVENTS,\n} from './lib/notification-manager';\nimport MetamaskController, {\n  METAMASK_CONTROLLER_EVENTS,\n} from './metamask-controller';\nimport rawFirstTimeState from './first-time-state';\nimport getFirstPreferredLangCode from './lib/get-first-preferred-lang-code';\nimport getObjStructure from './lib/getObjStructure';\nimport setupEnsIpfsResolver from './lib/ens-ipfs/setup';\nimport {\n  deferredPromise,\n  getPlatform,\n  shouldEmitDappViewedEvent,\n} from './lib/util';\nimport { generateWalletState } from './fixtures/generate-wallet-state';\nimport { createOffscreen } from './offscreen';\n\n/* eslint-enable import/first */\n\nimport { COOKIE_ID_MARKETING_WHITELIST_ORIGINS } from './constants/marketing-site-whitelist';\n\n// eslint-disable-next-line @metamask/design-tokens/color-no-hex\nconst BADGE_COLOR_APPROVAL = '#0376C9';\n// eslint-disable-next-line @metamask/design-tokens/color-no-hex\nconst BADGE_COLOR_NOTIFICATION = '#D73847';\nconst BADGE_MAX_COUNT = 9;\n\n// Setup global hook for improved Sentry state snapshots during initialization\nconst inTest = process.env.IN_TEST;\nconst localStore = inTest ? new ReadOnlyNetworkStore() : new LocalStore();\nglobal.stateHooks.getMostRecentPersistedState = () =>\n  localStore.mostRecentRetrievedState;\n\nconst { sentry } = global;\nlet firstTimeState = { ...rawFirstTimeState };\n\nconst metamaskInternalProcessHash = {\n  [ENVIRONMENT_TYPE_POPUP]: true,\n  [ENVIRONMENT_TYPE_NOTIFICATION]: true,\n  [ENVIRONMENT_TYPE_FULLSCREEN]: true,\n};\n\nconst metamaskBlockedPorts = ['trezor-connect'];\n\nlog.setLevel(process.env.METAMASK_DEBUG ? 'debug' : 'info', false);\n\nconst platform = new ExtensionPlatform();\nconst notificationManager = new NotificationManager();\n\nlet openPopupCount = 0;\nlet notificationIsOpen = false;\nlet uiIsTriggering = false;\nconst openMetamaskTabsIDs = {};\nconst requestAccountTabIds = {};\nlet controller;\nlet versionedData;\nconst tabOriginMapping = {};\n\nif (inTest || process.env.METAMASK_DEBUG) {\n  global.stateHooks.metamaskGetState = localStore.get.bind(localStore);\n}\n\nconst phishingPageUrl = new URL(process.env.PHISHING_WARNING_PAGE_URL);\n\n// normalized (adds a trailing slash to the end of the domain if it's missing)\n// the URL once and reuse it:\nconst phishingPageHref = phishingPageUrl.toString();\n\nconst ONE_SECOND_IN_MILLISECONDS = 1_000;\n// Timeout for initializing phishing warning page.\nconst PHISHING_WARNING_PAGE_TIMEOUT = ONE_SECOND_IN_MILLISECONDS;\n\n// Event emitter for state persistence\nexport const statePersistenceEvents = new EventEmitter();\n\n/**\n * This deferred Promise is used to track whether initialization has finished.\n *\n * It is very important to ensure that `resolveInitialization` is *always*\n * called once initialization has completed, and that `rejectInitialization` is\n * called if initialization fails in an unrecoverable way.\n */\nconst {\n  promise: isInitialized,\n  resolve: resolveInitialization,\n  reject: rejectInitialization,\n} = deferredPromise();\n\n/**\n * Sends a message to the dapp(s) content script to signal it can connect to MetaMask background as\n * the backend is not active. It is required to re-connect dapps after service worker re-activates.\n * For non-dapp pages, the message will be sent and ignored.\n */\nconst sendReadyMessageToTabs = async () => {\n  const tabs = await browser.tabs\n    .query({\n      /**\n       * Only query tabs that our extension can run in. To do this, we query for all URLs that our\n       * extension can inject scripts in, which is by using the \"<all_urls>\" value and __without__\n       * the \"tabs\" manifest permission. If we included the \"tabs\" permission, this would also fetch\n       * URLs that we'd not be able to inject in, e.g. chrome://pages, chrome://extension, which\n       * is not what we'd want.\n       *\n       * You might be wondering, how does the \"url\" param work without the \"tabs\" permission?\n       *\n       * @see {@link https://bugs.chromium.org/p/chromium/issues/detail?id=661311#c1}\n       *  \"If the extension has access to inject scripts into Tab, then we can return the url\n       *   of Tab (because the extension could just inject a script to message the location.href).\"\n       */\n      url: '<all_urls>',\n      windowType: 'normal',\n    })\n    .then((result) => {\n      checkForLastErrorAndLog();\n      return result;\n    })\n    .catch(() => {\n      checkForLastErrorAndLog();\n    });\n\n  /** @todo we should only sendMessage to dapp tabs, not all tabs. */\n  for (const tab of tabs) {\n    browser.tabs\n      .sendMessage(tab.id, {\n        name: EXTENSION_MESSAGES.READY,\n      })\n      .then(() => {\n        checkForLastErrorAndLog();\n      })\n      .catch(() => {\n        // An error may happen if the contentscript is blocked from loading,\n        // and thus there is no runtime.onMessage handler to listen to the message.\n        checkForLastErrorAndLog();\n      });\n  }\n};\n\n/**\n * Detects known phishing pages as soon as the browser begins to load the\n * page. If the page is a known phishing page, the user is redirected to the\n * phishing warning page.\n *\n * This detection works even if the phishing page is now a redirect to a new\n * domain that our phishing detection system is not aware of.\n *\n * @param {MetamaskController} theController\n */\nfunction maybeDetectPhishing(theController) {\n  async function redirectTab(tabId, url) {\n    try {\n      return await browser.tabs.update(tabId, {\n        url,\n      });\n    } catch (error) {\n      return sentry?.captureException(error);\n    }\n  }\n  // we can use the blocking API in MV2, but not in MV3\n  const isManifestV2 = !isManifestV3;\n  browser.webRequest.onBeforeRequest.addListener(\n    (details) => {\n      if (details.tabId === browser.tabs.TAB_ID_NONE) {\n        return {};\n      }\n\n      const { completedOnboarding } = theController.onboardingController.state;\n      if (!completedOnboarding) {\n        return {};\n      }\n\n      const prefState = theController.preferencesController.store.getState();\n      if (!prefState.usePhishDetect) {\n        return {};\n      }\n\n      // ignore requests that come from our phishing warning page, as\n      // the requests may come from the \"continue to site\" link, so we'll\n      // actually _want_ to bypass the phishing detection. We shouldn't have to\n      // do this, because the phishing site does tell the extension that the\n      // domain it blocked it now \"safe\", but it does this _after_ the request\n      // begins (which would get blocked by this listener). So we have to bail\n      // on detection here.\n      // This check can be removed once  https://github.com/MetaMask/phishing-warning/issues/160\n      // is shipped.\n      if (\n        details.initiator &&\n        // compare normalized URLs\n        new URL(details.initiator).host === phishingPageUrl.host\n      ) {\n        return {};\n      }\n\n      const { hostname, href, searchParams } = new URL(details.url);\n      if (inTest) {\n        if (searchParams.has('IN_TEST_BYPASS_EARLY_PHISHING_DETECTION')) {\n          // this is a test page that needs to bypass early phishing detection\n          return {};\n        }\n      }\n\n      theController.phishingController.maybeUpdateState();\n      const phishingTestResponse = theController.phishingController.test(\n        details.url,\n      );\n\n      const blockedRequestResponse =\n        theController.phishingController.isBlockedRequest(details.url);\n\n      // if the request is not blocked, and the phishing test is not blocked, return and don't show the phishing screen\n      if (!phishingTestResponse?.result && !blockedRequestResponse.result) {\n        return {};\n      }\n\n      // Determine the block reason based on the type\n      let blockReason;\n      if (phishingTestResponse?.result && blockedRequestResponse.result) {\n        blockReason = `${phishingTestResponse.type} and ${blockedRequestResponse.type}`;\n      } else if (phishingTestResponse?.result) {\n        blockReason = phishingTestResponse.type;\n      } else {\n        blockReason = blockedRequestResponse.type;\n      }\n\n      theController.metaMetricsController.trackEvent({\n        // should we differentiate between background redirection and content script redirection?\n        event: MetaMetricsEventName.PhishingPageDisplayed,\n        category: MetaMetricsEventCategory.Phishing,\n        properties: {\n          url: hostname,\n          reason: blockReason,\n        },\n      });\n      const querystring = new URLSearchParams({ hostname, href });\n      const redirectUrl = new URL(phishingPageHref);\n      redirectUrl.hash = querystring.toString();\n      const redirectHref = redirectUrl.toString();\n\n      // blocking is better than tab redirection, as blocking will prevent\n      // the browser from loading the page at all\n      if (isManifestV2) {\n        if (details.type === 'sub_frame') {\n          // redirect the entire tab to the\n          // phishing warning page instead.\n          redirectTab(details.tabId, redirectHref);\n          // don't let the sub_frame load at all\n          return { cancel: true };\n        }\n        // redirect the whole tab\n        return { redirectUrl: redirectHref };\n      }\n      // redirect the whole tab (even if it's a sub_frame request)\n      redirectTab(details.tabId, redirectHref);\n      return {};\n    },\n    {\n      types: ['main_frame', 'sub_frame', 'xmlhttprequest'],\n      urls: ['http://*/*', 'https://*/*'],\n    },\n    isManifestV2 ? ['blocking'] : [],\n  );\n}\n\n// These are set after initialization\nlet connectRemote;\nlet connectExternalExtension;\nlet connectExternalCaip;\n\nbrowser.runtime.onConnect.addListener(async (...args) => {\n  // Queue up connection attempts here, waiting until after initialization\n  await isInitialized;\n\n  // This is set in `setupController`, which is called as part of initialization\n  connectRemote(...args);\n});\nbrowser.runtime.onConnectExternal.addListener(async (...args) => {\n  // Queue up connection attempts here, waiting until after initialization\n  await isInitialized;\n  // This is set in `setupController`, which is called as part of initialization\n  const port = args[0];\n\n  if (port.sender.tab?.id && process.env.BARAD_DUR) {\n    connectExternalCaip(...args);\n  } else {\n    connectExternalExtension(...args);\n  }\n});\n\nfunction saveTimestamp() {\n  const timestamp = new Date().toISOString();\n\n  browser.storage.session.set({ timestamp });\n}\n\n/**\n * @typedef {import('@metamask/transaction-controller').TransactionMeta} TransactionMeta\n */\n\n/**\n * The data emitted from the MetaMaskController.store EventEmitter, also used to initialize the MetaMaskController. Available in UI on React state as state.metamask.\n *\n * @typedef MetaMaskState\n * @property {boolean} isInitialized - Whether the first vault has been created.\n * @property {boolean} isUnlocked - Whether the vault is currently decrypted and accounts are available for selection.\n * @property {boolean} isAccountMenuOpen - Represents whether the main account selection UI is currently displayed.\n * @property {boolean} isNetworkMenuOpen - Represents whether the main network selection UI is currently displayed.\n * @property {object} identities - An object matching lower-case hex addresses to Identity objects with \"address\" and \"name\" (nickname) keys.\n * @property {object} networkConfigurations - A list of network configurations, containing RPC provider details (eg chainId, rpcUrl, rpcPreferences).\n * @property {Array} addressBook - A list of previously sent to addresses.\n * @property {object} marketData - A map from chain ID -> contract address -> an object containing the token's market data.\n * @property {Array} tokens - Tokens held by the current user, including their balances.\n * @property {object} send - TODO: Document\n * @property {boolean} useBlockie - Indicates preferred user identicon format. True for blockie, false for Jazzicon.\n * @property {object} featureFlags - An object for optional feature flags.\n * @property {boolean} welcomeScreen - True if welcome screen should be shown.\n * @property {string} currentLocale - A locale string matching the user's preferred display language.\n * @property {string} networkStatus - Either \"unknown\", \"available\", \"unavailable\", or \"blocked\", depending on the status of the currently selected network.\n * @property {object} accounts - An object mapping lower-case hex addresses to objects with \"balance\" and \"address\" keys, both storing hex string values.\n * @property {object} accountsByChainId - An object mapping lower-case hex addresses to objects with \"balance\" and \"address\" keys, both storing hex string values keyed by chain id.\n * @property {hex} currentBlockGasLimit - The most recently seen block gas limit, in a lower case hex prefixed string.\n * @property {object} currentBlockGasLimitByChainId - The most recently seen block gas limit, in a lower case hex prefixed string keyed by chain id.\n * @property {object} unapprovedPersonalMsgs - An object of messages pending approval, mapping a unique ID to the options.\n * @property {number} unapprovedPersonalMsgCount - The number of messages in unapprovedPersonalMsgs.\n * @property {object} unapprovedEncryptionPublicKeyMsgs - An object of messages pending approval, mapping a unique ID to the options.\n * @property {number} unapprovedEncryptionPublicKeyMsgCount - The number of messages in EncryptionPublicKeyMsgs.\n * @property {object} unapprovedDecryptMsgs - An object of messages pending approval, mapping a unique ID to the options.\n * @property {number} unapprovedDecryptMsgCount - The number of messages in unapprovedDecryptMsgs.\n * @property {object} unapprovedTypedMessages - An object of messages pending approval, mapping a unique ID to the options.\n * @property {number} unapprovedTypedMessagesCount - The number of messages in unapprovedTypedMessages.\n * @property {number} pendingApprovalCount - The number of pending request in the approval controller.\n * @property {Keyring[]} keyrings - An array of keyring descriptions, summarizing the accounts that are available for use, and what keyrings they belong to.\n * @property {string} selectedAddress - A lower case hex string of the currently selected address.\n * @property {string} currentCurrency - A string identifying the user's preferred display currency, for use in showing conversion rates.\n * @property {number} currencyRates - An object mapping of nativeCurrency to conversion rate and date\n * @property {boolean} forgottenPassword - Returns true if the user has initiated the password recovery screen, is recovering from seed phrase.\n */\n\n/**\n * @typedef VersionedData\n * @property {MetaMaskState} data - The data emitted from MetaMask controller, or used to initialize it.\n * @property {number} version - The latest migration version that has been run.\n */\n\n/**\n * Initializes the MetaMask controller, and sets up all platform configuration.\n *\n * @returns {Promise} Setup complete.\n */\nasync function initialize() {\n  try {\n    const offscreenPromise = isManifestV3 ? createOffscreen() : null;\n\n    const initData = await loadStateFromPersistence();\n\n    const initState = initData.data;\n    const initLangCode = await getFirstPreferredLangCode();\n\n    let isFirstMetaMaskControllerSetup;\n\n    // We only want to start this if we are running a test build, not for the release build.\n    // `navigator.webdriver` is true if Selenium, Puppeteer, or Playwright are running.\n    // In MV3, the Service Worker sees `navigator.webdriver` as `undefined`, so this will trigger from\n    // an Offscreen Document message instead. Because it's a singleton class, it's safe to start multiple times.\n    if (process.env.IN_TEST && window.navigator?.webdriver) {\n      getSocketBackgroundToMocha();\n    }\n\n    if (isManifestV3) {\n      // Save the timestamp immediately and then every `SAVE_TIMESTAMP_INTERVAL`\n      // miliseconds. This keeps the service worker alive.\n      if (initState.PreferencesController?.enableMV3TimestampSave !== false) {\n        const SAVE_TIMESTAMP_INTERVAL_MS = 2 * 1000;\n\n        saveTimestamp();\n        setInterval(saveTimestamp, SAVE_TIMESTAMP_INTERVAL_MS);\n      }\n\n      const sessionData = await browser.storage.session.get([\n        'isFirstMetaMaskControllerSetup',\n      ]);\n\n      isFirstMetaMaskControllerSetup =\n        sessionData?.isFirstMetaMaskControllerSetup === undefined;\n      await browser.storage.session.set({ isFirstMetaMaskControllerSetup });\n    }\n\n    const overrides = inTest\n      ? {\n          keyrings: {\n            trezorBridge: FakeTrezorBridge,\n            ledgerBridge: FakeLedgerBridge,\n          },\n        }\n      : {};\n\n    setupController(\n      initState,\n      initLangCode,\n      overrides,\n      isFirstMetaMaskControllerSetup,\n      initData.meta,\n      offscreenPromise,\n    );\n\n    // `setupController` sets up the `controller` object, so we can use it now:\n    maybeDetectPhishing(controller);\n\n    if (!isManifestV3) {\n      await loadPhishingWarningPage();\n    }\n    await sendReadyMessageToTabs();\n    log.info('MetaMask initialization complete.');\n\n    resolveInitialization();\n  } catch (error) {\n    rejectInitialization(error);\n  }\n}\n\n/**\n * An error thrown if the phishing warning page takes too long to load.\n */\nclass PhishingWarningPageTimeoutError extends Error {\n  constructor() {\n    super('Timeout failed');\n  }\n}\n\n/**\n * Load the phishing warning page temporarily to ensure the service\n * worker has been registered, so that the warning page works offline.\n */\nasync function loadPhishingWarningPage() {\n  let iframe;\n  try {\n    const extensionStartupPhishingPageUrl = new URL(phishingPageHref);\n    // The `extensionStartup` hash signals to the phishing warning page that it should not bother\n    // setting up streams for user interaction. Otherwise this page load would cause a console\n    // error.\n    extensionStartupPhishingPageUrl.hash = '#extensionStartup';\n\n    iframe = window.document.createElement('iframe');\n    iframe.setAttribute('src', extensionStartupPhishingPageUrl.href);\n    iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin');\n\n    // Create \"deferred Promise\" to allow passing resolve/reject to event handlers\n    let deferredResolve;\n    let deferredReject;\n    const loadComplete = new Promise((resolve, reject) => {\n      deferredResolve = resolve;\n      deferredReject = reject;\n    });\n\n    // The load event is emitted once loading has completed, even if the loading failed.\n    // If loading failed we can't do anything about it, so we don't need to check.\n    iframe.addEventListener('load', deferredResolve);\n\n    // This step initiates the page loading.\n    window.document.body.appendChild(iframe);\n\n    // This timeout ensures that this iframe gets cleaned up in a reasonable\n    // timeframe, and ensures that the \"initialization complete\" message\n    // doesn't get delayed too long.\n    setTimeout(\n      () => deferredReject(new PhishingWarningPageTimeoutError()),\n      PHISHING_WARNING_PAGE_TIMEOUT,\n    );\n    await loadComplete;\n  } catch (error) {\n    if (error instanceof PhishingWarningPageTimeoutError) {\n      console.warn(\n        'Phishing warning page timeout; page not guaranteed to work offline.',\n      );\n    } else {\n      console.error('Failed to initialize phishing warning page', error);\n    }\n  } finally {\n    if (iframe) {\n      iframe.remove();\n    }\n  }\n}\n\n//\n// State and Persistence\n//\n\n/**\n * Loads any stored data, prioritizing the latest storage strategy.\n * Migrates that data schema in case it was last loaded on an older version.\n *\n * @returns {Promise<MetaMaskState>} Last data emitted from previous instance of MetaMask.\n */\nexport async function loadStateFromPersistence() {\n  // migrations\n  const migrator = new Migrator({\n    migrations,\n    defaultVersion: process.env.WITH_STATE\n      ? FIXTURE_STATE_METADATA_VERSION\n      : null,\n  });\n  migrator.on('error', console.warn);\n\n  if (process.env.WITH_STATE) {\n    const stateOverrides = await generateWalletState();\n    firstTimeState = { ...firstTimeState, ...stateOverrides };\n  }\n\n  // read from disk\n  // first from preferred, async API:\n  versionedData =\n    (await localStore.get()) || migrator.generateInitialState(firstTimeState);\n\n  // check if somehow state is empty\n  // this should never happen but new error reporting suggests that it has\n  // for a small number of users\n  // https://github.com/metamask/metamask-extension/issues/3919\n  if (versionedData && !versionedData.data) {\n    // unable to recover, clear state\n    versionedData = migrator.generateInitialState(firstTimeState);\n    sentry.captureMessage('MetaMask - Empty vault found - unable to recover');\n  }\n\n  // report migration errors to sentry\n  migrator.on('error', (err) => {\n    // get vault structure without secrets\n    const vaultStructure = getObjStructure(versionedData);\n    sentry.captureException(err, {\n      // \"extra\" key is required by Sentry\n      extra: { vaultStructure },\n    });\n  });\n\n  // migrate data\n  versionedData = await migrator.migrateData(versionedData);\n  if (!versionedData) {\n    throw new Error('MetaMask - migrator returned undefined');\n  } else if (!isObject(versionedData.meta)) {\n    throw new Error(\n      `MetaMask - migrator metadata has invalid type '${typeof versionedData.meta}'`,\n    );\n  } else if (typeof versionedData.meta.version !== 'number') {\n    throw new Error(\n      `MetaMask - migrator metadata version has invalid type '${typeof versionedData\n        .meta.version}'`,\n    );\n  } else if (!isObject(versionedData.data)) {\n    throw new Error(\n      `MetaMask - migrator data has invalid type '${typeof versionedData.data}'`,\n    );\n  }\n  // this initializes the meta/version data as a class variable to be used for future writes\n  localStore.setMetadata(versionedData.meta);\n\n  // write to disk\n  localStore.set(versionedData.data);\n\n  // return just the data\n  return versionedData;\n}\n\n/**\n * Emit event of DappViewed,\n * which should only be tracked only after a user opts into metrics and connected to the dapp\n *\n * @param {string} origin - URL of visited dapp\n */\nfunction emitDappViewedMetricEvent(origin) {\n  const { metaMetricsId } = controller.metaMetricsController.state;\n  if (!shouldEmitDappViewedEvent(metaMetricsId)) {\n    return;\n  }\n\n  const permissions = controller.controllerMessenger.call(\n    'PermissionController:getPermissions',\n    origin,\n  );\n  const numberOfConnectedAccounts =\n    permissions?.eth_accounts?.caveats[0]?.value.length;\n  if (!numberOfConnectedAccounts) {\n    return;\n  }\n\n  const preferencesState = controller.controllerMessenger.call(\n    'PreferencesController:getState',\n  );\n  const numberOfTotalAccounts = Object.keys(preferencesState.identities).length;\n\n  controller.metaMetricsController.trackEvent({\n    event: MetaMetricsEventName.DappViewed,\n    category: MetaMetricsEventCategory.InpageProvider,\n    referrer: {\n      url: origin,\n    },\n    properties: {\n      is_first_visit: false,\n      number_of_accounts: numberOfTotalAccounts,\n      number_of_accounts_connected: numberOfConnectedAccounts,\n    },\n  });\n}\n\n/**\n * Track dapp connection when loaded and permissioned\n *\n * @param {Port} remotePort - The port provided by a new context.\n */\nfunction trackDappView(remotePort) {\n  if (!remotePort.sender || !remotePort.sender.tab || !remotePort.sender.url) {\n    return;\n  }\n  const tabId = remotePort.sender.tab.id;\n  const url = new URL(remotePort.sender.url);\n  const { origin } = url;\n\n  // store the orgin to corresponding tab so it can provide infor for onActivated listener\n  if (!Object.keys(tabOriginMapping).includes(tabId)) {\n    tabOriginMapping[tabId] = origin;\n  }\n\n  const isConnectedToDapp = controller.controllerMessenger.call(\n    'PermissionController:hasPermissions',\n    origin,\n  );\n\n  // when open a new tab, this event will trigger twice, only 2nd time is with dapp loaded\n  const isTabLoaded = remotePort.sender.tab.title !== 'New Tab';\n\n  // *** Emit DappViewed metric event when ***\n  // - refresh the dapp\n  // - open dapp in a new tab\n  if (isConnectedToDapp && isTabLoaded) {\n    emitDappViewedMetricEvent(origin);\n  }\n}\n\n/**\n * Initializes the MetaMask Controller with any initial state and default language.\n * Configures platform-specific error reporting strategy.\n * Streams emitted state updates to platform-specific storage strategy.\n * Creates platform listeners for new Dapps/Contexts, and sets up their data connections to the controller.\n *\n * @param {object} initState - The initial state to start the controller with, matches the state that is emitted from the controller.\n * @param {string} initLangCode - The region code for the language preferred by the current user.\n * @param {object} overrides - object with callbacks that are allowed to override the setup controller logic\n * @param isFirstMetaMaskControllerSetup\n * @param {object} stateMetadata - Metadata about the initial state and migrations, including the most recent migration version\n * @param {Promise<void>} offscreenPromise - A promise that resolves when the offscreen document has finished initialization.\n */\nexport function setupController(\n  initState,\n  initLangCode,\n  overrides,\n  isFirstMetaMaskControllerSetup,\n  stateMetadata,\n  offscreenPromise,\n) {\n  //\n  // MetaMask Controller\n  //\n\n  controller = new MetamaskController({\n    infuraProjectId: process.env.INFURA_PROJECT_ID,\n    // User confirmation callbacks:\n    showUserConfirmation: triggerUi,\n    // initial state\n    initState,\n    // initial locale code\n    initLangCode,\n    // platform specific api\n    platform,\n    notificationManager,\n    browser,\n    getRequestAccountTabIds: () => {\n      return requestAccountTabIds;\n    },\n    getOpenMetamaskTabsIds: () => {\n      return openMetamaskTabsIDs;\n    },\n    localStore,\n    overrides,\n    isFirstMetaMaskControllerSetup,\n    currentMigrationVersion: stateMetadata.version,\n    featureFlags: {},\n    offscreenPromise,\n  });\n\n  setupEnsIpfsResolver({\n    getCurrentChainId: () =>\n      getCurrentChainId({ metamask: controller.networkController.state }),\n    getIpfsGateway: controller.preferencesController.getIpfsGateway.bind(\n      controller.preferencesController,\n    ),\n    getUseAddressBarEnsResolution: () =>\n      controller.preferencesController.store.getState()\n        .useAddressBarEnsResolution,\n    provider: controller.provider,\n  });\n\n  // setup state persistence\n  pipeline(\n    storeAsStream(controller.store),\n    debounce(1000),\n    createStreamSink(async (state) => {\n      await localStore.set(state);\n      statePersistenceEvents.emit('state-persisted', state);\n    }),\n    (error) => {\n      log.error('MetaMask - Persistence pipeline failed', error);\n    },\n  );\n\n  setupSentryGetStateGlobal(controller);\n\n  const isClientOpenStatus = () => {\n    return (\n      openPopupCount > 0 ||\n      Boolean(Object.keys(openMetamaskTabsIDs).length) ||\n      notificationIsOpen\n    );\n  };\n\n  const onCloseEnvironmentInstances = (isClientOpen, environmentType) => {\n    // if all instances of metamask are closed we call a method on the controller to stop gasFeeController polling\n    if (isClientOpen === false) {\n      controller.onClientClosed();\n      // otherwise we want to only remove the polling tokens for the environment type that has closed\n    } else {\n      // in the case of fullscreen environment a user might have multiple tabs open so we don't want to disconnect all of\n      // its corresponding polling tokens unless all tabs are closed.\n      if (\n        environmentType === ENVIRONMENT_TYPE_FULLSCREEN &&\n        Boolean(Object.keys(openMetamaskTabsIDs).length)\n      ) {\n        return;\n      }\n      controller.onEnvironmentTypeClosed(environmentType);\n    }\n  };\n\n  /**\n   * A runtime.Port object, as provided by the browser:\n   *\n   * @see https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/runtime/Port\n   * @typedef Port\n   * @type Object\n   */\n\n  /**\n   * Connects a Port to the MetaMask controller via a multiplexed duplex stream.\n   * This method identifies trusted (MetaMask) interfaces, and connects them differently from untrusted (web pages).\n   *\n   * @param {Port} remotePort - The port provided by a new context.\n   */\n  connectRemote = async (remotePort) => {\n    const processName = remotePort.name;\n\n    if (metamaskBlockedPorts.includes(remotePort.name)) {\n      return;\n    }\n\n    let isMetaMaskInternalProcess = false;\n    const sourcePlatform = getPlatform();\n    const senderUrl = remotePort.sender?.url\n      ? new URL(remotePort.sender.url)\n      : null;\n\n    if (sourcePlatform === PLATFORM_FIREFOX) {\n      isMetaMaskInternalProcess = metamaskInternalProcessHash[processName];\n    } else {\n      isMetaMaskInternalProcess =\n        senderUrl?.origin === `chrome-extension://${browser.runtime.id}`;\n    }\n\n    if (isMetaMaskInternalProcess) {\n      const portStream =\n        overrides?.getPortStream?.(remotePort) || new PortStream(remotePort);\n      // communication with popup\n      controller.isClientOpen = true;\n      controller.setupTrustedCommunication(portStream, remotePort.sender);\n\n      if (processName === ENVIRONMENT_TYPE_POPUP) {\n        openPopupCount += 1;\n        finished(portStream, () => {\n          openPopupCount -= 1;\n          const isClientOpen = isClientOpenStatus();\n          controller.isClientOpen = isClientOpen;\n          onCloseEnvironmentInstances(isClientOpen, ENVIRONMENT_TYPE_POPUP);\n        });\n      }\n\n      if (processName === ENVIRONMENT_TYPE_NOTIFICATION) {\n        notificationIsOpen = true;\n\n        finished(portStream, () => {\n          notificationIsOpen = false;\n          const isClientOpen = isClientOpenStatus();\n          controller.isClientOpen = isClientOpen;\n          onCloseEnvironmentInstances(\n            isClientOpen,\n            ENVIRONMENT_TYPE_NOTIFICATION,\n          );\n        });\n      }\n\n      if (processName === ENVIRONMENT_TYPE_FULLSCREEN) {\n        const tabId = remotePort.sender.tab.id;\n        openMetamaskTabsIDs[tabId] = true;\n\n        finished(portStream, () => {\n          delete openMetamaskTabsIDs[tabId];\n          const isClientOpen = isClientOpenStatus();\n          controller.isClientOpen = isClientOpen;\n          onCloseEnvironmentInstances(\n            isClientOpen,\n            ENVIRONMENT_TYPE_FULLSCREEN,\n          );\n        });\n      }\n    } else if (\n      senderUrl &&\n      senderUrl.origin === phishingPageUrl.origin &&\n      senderUrl.pathname === phishingPageUrl.pathname\n    ) {\n      const portStreamForPhishingPage =\n        overrides?.getPortStream?.(remotePort) || new PortStream(remotePort);\n      controller.setupPhishingCommunication({\n        connectionStream: portStreamForPhishingPage,\n      });\n    } else {\n      // this is triggered when a new tab is opened, or origin(url) is changed\n      if (remotePort.sender && remotePort.sender.tab && remotePort.sender.url) {\n        const tabId = remotePort.sender.tab.id;\n        const url = new URL(remotePort.sender.url);\n        const { origin } = url;\n\n        trackDappView(remotePort);\n\n        remotePort.onMessage.addListener((msg) => {\n          if (\n            msg.data &&\n            msg.data.method === MESSAGE_TYPE.ETH_REQUEST_ACCOUNTS\n          ) {\n            requestAccountTabIds[origin] = tabId;\n          }\n        });\n      }\n      if (\n        senderUrl &&\n        COOKIE_ID_MARKETING_WHITELIST_ORIGINS.some(\n          (origin) => origin === senderUrl.origin,\n        )\n      ) {\n        const portStreamForCookieHandlerPage =\n          overrides?.getPortStream?.(remotePort) || new PortStream(remotePort);\n        controller.setUpCookieHandlerCommunication({\n          connectionStream: portStreamForCookieHandlerPage,\n        });\n      }\n      connectExternalExtension(remotePort);\n    }\n  };\n\n  // communication with page or other extension\n  connectExternalExtension = (remotePort) => {\n    const portStream =\n      overrides?.getPortStream?.(remotePort) || new PortStream(remotePort);\n    controller.setupUntrustedCommunicationEip1193({\n      connectionStream: portStream,\n      sender: remotePort.sender,\n    });\n  };\n\n  connectExternalCaip = async (remotePort) => {\n    if (metamaskBlockedPorts.includes(remotePort.name)) {\n      return;\n    }\n\n    // this is triggered when a new tab is opened, or origin(url) is changed\n    if (remotePort.sender && remotePort.sender.tab && remotePort.sender.url) {\n      trackDappView(remotePort);\n    }\n\n    const portStream =\n      overrides?.getPortStream?.(remotePort) || new PortStream(remotePort);\n\n    controller.setupUntrustedCommunicationCaip({\n      connectionStream: portStream,\n      sender: remotePort.sender,\n    });\n  };\n\n  if (overrides?.registerConnectListeners) {\n    overrides.registerConnectListeners(connectRemote, connectExternalExtension);\n  }\n\n  //\n  // User Interface setup\n  //\n  updateBadge();\n\n  controller.decryptMessageController.hub.on(\n    METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE,\n    updateBadge,\n  );\n  controller.encryptionPublicKeyController.hub.on(\n    METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE,\n    updateBadge,\n  );\n  controller.signatureController.hub.on(\n    METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE,\n    updateBadge,\n  );\n  controller.appStateController.on(\n    METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE,\n    updateBadge,\n  );\n\n  controller.controllerMessenger.subscribe(\n    METAMASK_CONTROLLER_EVENTS.APPROVAL_STATE_CHANGE,\n    updateBadge,\n  );\n\n  controller.controllerMessenger.subscribe(\n    METAMASK_CONTROLLER_EVENTS.QUEUED_REQUEST_STATE_CHANGE,\n    updateBadge,\n  );\n\n  controller.controllerMessenger.subscribe(\n    METAMASK_CONTROLLER_EVENTS.METAMASK_NOTIFICATIONS_LIST_UPDATED,\n    updateBadge,\n  );\n\n  controller.controllerMessenger.subscribe(\n    METAMASK_CONTROLLER_EVENTS.METAMASK_NOTIFICATIONS_MARK_AS_READ,\n    updateBadge,\n  );\n\n  controller.controllerMessenger.subscribe(\n    METAMASK_CONTROLLER_EVENTS.NOTIFICATIONS_STATE_CHANGE,\n    updateBadge,\n  );\n\n  /**\n   * Formats a count for display as a badge label.\n   *\n   * @param {number} count - The count to be formatted.\n   * @param {number} maxCount - The maximum count to display before using the '+' suffix.\n   * @returns {string} The formatted badge label.\n   */\n  function getBadgeLabel(count, maxCount) {\n    return count > maxCount ? `${maxCount}+` : String(count);\n  }\n\n  /**\n   * Updates the Web Extension's \"badge\" number, on the little fox in the toolbar.\n   * The number reflects the current number of pending transactions or message signatures needing user approval.\n   */\n  function updateBadge() {\n    const pendingApprovalCount = getPendingApprovalCount();\n    const unreadNotificationsCount = getUnreadNotificationsCount();\n\n    let label = '';\n    let badgeColor = BADGE_COLOR_APPROVAL;\n\n    if (pendingApprovalCount) {\n      label = getBadgeLabel(pendingApprovalCount, BADGE_MAX_COUNT);\n    } else if (unreadNotificationsCount > 0) {\n      label = getBadgeLabel(unreadNotificationsCount, BADGE_MAX_COUNT);\n      badgeColor = BADGE_COLOR_NOTIFICATION;\n    }\n\n    try {\n      const badgeText = { text: label };\n      const badgeBackgroundColor = { color: badgeColor };\n\n      if (isManifestV3) {\n        browser.action.setBadgeText(badgeText);\n        browser.action.setBadgeBackgroundColor(badgeBackgroundColor);\n      } else {\n        browser.browserAction.setBadgeText(badgeText);\n        browser.browserAction.setBadgeBackgroundColor(badgeBackgroundColor);\n      }\n    } catch (error) {\n      console.error('Error updating browser badge:', error);\n    }\n  }\n\n  function getPendingApprovalCount() {\n    try {\n      let pendingApprovalCount =\n        controller.appStateController.waitingForUnlock.length +\n        controller.approvalController.getTotalApprovalCount();\n\n      if (controller.preferencesController.getUseRequestQueue()) {\n        pendingApprovalCount +=\n          controller.queuedRequestController.state.queuedRequestCount;\n      }\n      return pendingApprovalCount;\n    } catch (error) {\n      console.error('Failed to get pending approval count:', error);\n      return 0;\n    }\n  }\n\n  function getUnreadNotificationsCount() {\n    try {\n      const { isNotificationServicesEnabled, isFeatureAnnouncementsEnabled } =\n        controller.notificationServicesController.state;\n\n      const snapNotificationCount = Object.values(\n        controller.notificationController.state.notifications,\n      ).filter((notification) => notification.readDate === null).length;\n\n      const featureAnnouncementCount = isFeatureAnnouncementsEnabled\n        ? controller.notificationServicesController.state.metamaskNotificationsList.filter(\n            (notification) =>\n              !notification.isRead &&\n              notification.type ===\n                NotificationServicesController.Constants.TRIGGER_TYPES\n                  .FEATURES_ANNOUNCEMENT,\n          ).length\n        : 0;\n\n      const walletNotificationCount = isNotificationServicesEnabled\n        ? controller.notificationServicesController.state.metamaskNotificationsList.filter(\n            (notification) =>\n              !notification.isRead &&\n              notification.type !==\n                NotificationServicesController.Constants.TRIGGER_TYPES\n                  .FEATURES_ANNOUNCEMENT,\n          ).length\n        : 0;\n\n      const unreadNotificationsCount =\n        snapNotificationCount +\n        featureAnnouncementCount +\n        walletNotificationCount;\n\n      return unreadNotificationsCount;\n    } catch (error) {\n      console.error('Failed to get unread notifications count:', error);\n      return 0;\n    }\n  }\n\n  notificationManager.on(\n    NOTIFICATION_MANAGER_EVENTS.POPUP_CLOSED,\n    ({ automaticallyClosed }) => {\n      if (!automaticallyClosed) {\n        rejectUnapprovedNotifications();\n      } else if (getPendingApprovalCount() > 0) {\n        triggerUi();\n      }\n\n      updateBadge();\n    },\n  );\n\n  function rejectUnapprovedNotifications() {\n    controller.signatureController.rejectUnapproved(\n      REJECT_NOTIFICATION_CLOSE_SIG,\n    );\n    controller.decryptMessageController.rejectUnapproved(\n      REJECT_NOTIFICATION_CLOSE,\n    );\n    controller.encryptionPublicKeyController.rejectUnapproved(\n      REJECT_NOTIFICATION_CLOSE,\n    );\n\n    // Finally, resolve snap dialog approvals on Flask and reject all the others managed by the ApprovalController.\n    Object.values(controller.approvalController.state.pendingApprovals).forEach(\n      ({ id, type }) => {\n        switch (type) {\n          case ApprovalType.SnapDialogAlert:\n          case ApprovalType.SnapDialogPrompt:\n          case DIALOG_APPROVAL_TYPES.default:\n            controller.approvalController.accept(id, null);\n            break;\n          case ApprovalType.SnapDialogConfirmation:\n            controller.approvalController.accept(id, false);\n            break;\n          ///: BEGIN:ONLY_INCLUDE_IF(keyring-snaps)\n          case SNAP_MANAGE_ACCOUNTS_CONFIRMATION_TYPES.confirmAccountCreation:\n          case SNAP_MANAGE_ACCOUNTS_CONFIRMATION_TYPES.confirmAccountRemoval:\n          case SNAP_MANAGE_ACCOUNTS_CONFIRMATION_TYPES.showSnapAccountRedirect:\n            controller.approvalController.accept(id, false);\n            break;\n          ///: END:ONLY_INCLUDE_IF\n          default:\n            controller.approvalController.reject(\n              id,\n              ethErrors.provider.userRejectedRequest(),\n            );\n            break;\n        }\n      },\n    );\n  }\n\n  // Updates the snaps registry and check for newly blocked snaps to block if the user has at least one snap installed that isn't preinstalled.\n  if (\n    Object.values(controller.snapController.state.snaps).some(\n      (snap) => !snap.preinstalled,\n    )\n  ) {\n    controller.snapController.updateBlockedSnaps();\n  }\n}\n\n//\n// Etc...\n//\n\n/**\n * Opens the browser popup for user confirmation\n */\nasync function triggerUi() {\n  const tabs = await platform.getActiveTabs();\n  const currentlyActiveMetamaskTab = Boolean(\n    tabs.find((tab) => openMetamaskTabsIDs[tab.id]),\n  );\n  // Vivaldi is not closing port connection on popup close, so openPopupCount does not work correctly\n  // To be reviewed in the future if this behaviour is fixed - also the way we determine isVivaldi variable might change at some point\n  const isVivaldi =\n    tabs.length > 0 &&\n    tabs[0].extData &&\n    tabs[0].extData.indexOf('vivaldi_tab') > -1;\n  if (\n    !uiIsTriggering &&\n    (isVivaldi || openPopupCount === 0) &&\n    !currentlyActiveMetamaskTab\n  ) {\n    uiIsTriggering = true;\n    try {\n      const currentPopupId = controller.appStateController.getCurrentPopupId();\n      await notificationManager.showPopup(\n        (newPopupId) =>\n          controller.appStateController.setCurrentPopupId(newPopupId),\n        currentPopupId,\n      );\n    } finally {\n      uiIsTriggering = false;\n    }\n  }\n}\n\n// It adds the \"App Installed\" event into a queue of events, which will be tracked only after a user opts into metrics.\nconst addAppInstalledEvent = () => {\n  if (controller) {\n    controller.metaMetricsController.updateTraits({\n      [MetaMetricsUserTrait.InstallDateExt]: new Date()\n        .toISOString()\n        .split('T')[0], // yyyy-mm-dd\n    });\n    controller.metaMetricsController.addEventBeforeMetricsOptIn({\n      category: MetaMetricsEventCategory.App,\n      event: MetaMetricsEventName.AppInstalled,\n      properties: {},\n    });\n    return;\n  }\n  setTimeout(() => {\n    // If the controller is not set yet, we wait and try to add the \"App Installed\" event again.\n    addAppInstalledEvent();\n  }, 500);\n};\n\n// On first install, open a new tab with MetaMask\nasync function onInstall() {\n  const storeAlreadyExisted = Boolean(await localStore.get());\n  // If the store doesn't exist, then this is the first time running this script,\n  // and is therefore an install\n  if (process.env.IN_TEST) {\n    addAppInstalledEvent();\n  } else if (!storeAlreadyExisted && !process.env.METAMASK_DEBUG) {\n    addAppInstalledEvent();\n    platform.openExtensionInBrowser();\n  }\n  onNavigateToTab();\n}\n\nfunction onNavigateToTab() {\n  browser.tabs.onActivated.addListener((onActivatedTab) => {\n    if (controller) {\n      const { tabId } = onActivatedTab;\n      const currentOrigin = tabOriginMapping[tabId];\n      // *** Emit DappViewed metric event when ***\n      // - navigate to a connected dapp\n      if (currentOrigin) {\n        const connectSitePermissions =\n          controller.permissionController.state.subjects[currentOrigin];\n        // when the dapp is not connected, connectSitePermissions is undefined\n        const isConnectedToDapp = connectSitePermissions !== undefined;\n        if (isConnectedToDapp) {\n          emitDappViewedMetricEvent(currentOrigin);\n        }\n      }\n    }\n  });\n}\n\nfunction setupSentryGetStateGlobal(store) {\n  global.stateHooks.getSentryAppState = function () {\n    const backgroundState = store.memStore.getState();\n    return maskObject(backgroundState, SENTRY_BACKGROUND_STATE);\n  };\n}\n\nasync function initBackground() {\n  await onInstall();\n  try {\n    await initialize();\n    if (process.env.IN_TEST) {\n      // Send message to offscreen document\n      if (browser.offscreen) {\n        browser.runtime.sendMessage({\n          target: OffscreenCommunicationTarget.extension,\n          event: OffscreenCommunicationEvents.metamaskBackgroundReady,\n        });\n      } else {\n        window.document?.documentElement?.classList.add('controller-loaded');\n      }\n    }\n    localStore.cleanUpMostRecentRetrievedState();\n  } catch (error) {\n    log.error(error);\n  }\n}\nif (!process.env.SKIP_BACKGROUND_INITIALIZATION) {\n  initBackground();\n}\n"]}